# Environment File (.env) Generation

This document explains how the `env.*` schema routing works and how `.env` files are generated for each application.

---

## Overview

When you use `"schema": "env.VARIABLE_NAME"` in a blueprint field, the value is:
1. **NOT** included in the Docker Compose YAML file
2. **IS** written to the `.env` file in the app's stack directory
3. **IS** available as an environment variable during compose execution

---

## How It Works

### 1. Blueprint Definition

In your blueprint JSON:

```json
{
  "tag": {
    "type": "string",
    "ui_component": "text",
    "label": "Image Tag",
    "default": "latest",
    "description": "Docker image tag/version to use",
    "schema": "env.TAG"
  }
}
```

The key part: `"schema": "env.TAG"`

### 2. Schema Routing

When the app is created, the routing system (`routes/apps.py`) processes each field:

```python
# From routes/apps.py
for field_name, field_config in blueprint.schema_json.items():
    schema_path = field_config.get('schema', '')

    if schema_path.startswith('env.'):
        # Value goes to .env file (handled later)
        continue
    elif schema_path.startswith('service.'):
        # Value goes to service_data
        set_nested_value(service_data, schema_path[8:], value)
    elif schema_path.startswith('compose.'):
        # Value goes to compose_data
        set_nested_value(compose_data, schema_path[8:], value)
    elif schema_path.startswith('metadata.'):
        # Value goes to metadata_data
        set_nested_value(metadata_data, schema_path[9:], value)
```

Fields with `env.*` schema are stored in `raw_inputs` but **not** routed to service_data, compose_data, or metadata_data.

### 3. .env File Generation

When the app is installed, the `ComposeGenerator.generate_env_file()` method creates the `.env` file:

```python
# From services/compose_generator.py
def generate_env_file(self, app_name: str, user_inputs: Dict[str, Any], blueprint: Blueprint) -> str:
    host_path = self.path_resolver.get_host_stack_path(app_name)

    env_vars = {}
    env_vars['HOST_PATH'] = host_path  # Always included

    # Extract fields with schema: "env.*" from blueprint
    for field_name, field_config in blueprint.schema_json.items():
        schema_path = field_config.get('schema', '')
        if schema_path.startswith('env.'):
            env_var_name = schema_path.split('.', 1)[1]  # Get "TAG" from "env.TAG"
            value = user_inputs.get(field_name)
            if value is not None:
                env_vars[env_var_name] = value

    # Build .env file content
    lines = [
        "# Auto-generated by Mastarr",
        f"# Application: {app_name}",
        f"# Generated: {datetime.now().isoformat()}",
        "",
        "# Host path for this stack - used for volume mounts",
        f"HOST_PATH={host_path}",
        ""
    ]

    # Add other env vars
    for key, value in env_vars.items():
        if key != 'HOST_PATH':
            lines.append(f"{key}={value}")

    return '\n'.join(lines)
```

### 4. Result

The generated `.env` file looks like:

```env
# Auto-generated by Mastarr
# Application: jellyfin_1234567890
# Generated: 2024-10-30T12:34:56

# Host path for this stack - used for volume mounts
HOST_PATH=/opt/mastarr/stacks/jellyfin_1234567890

TAG=latest
```

### 5. Usage in Docker Compose

In the Docker Compose file, you reference the variable:

```yaml
services:
  jellyfin:
    image: jellyfin/jellyfin:${TAG:-latest}
```

When Docker Compose runs, it:
1. Reads the `.env` file in the same directory
2. Substitutes `${TAG}` with the value from `.env` (or `latest` as fallback)
3. Final result: `image: jellyfin/jellyfin:latest`

---

## Common Environment Variables

### HOST_PATH

**Always Included:** Yes (automatically)

**Purpose:** Base path for volume mounts

**Example:**
```env
HOST_PATH=/opt/mastarr/stacks/app_name
```

**Usage in Compose:**
```yaml
volumes:
  - type: bind
    source: ${HOST_PATH}/config
    target: /config
```

### TAG

**Purpose:** Docker image tag/version

**Blueprint:**
```json
{
  "tag": {
    "type": "string",
    "ui_component": "text",
    "label": "Image Tag",
    "default": "latest",
    "schema": "env.TAG"
  }
}
```

**Usage in Compose:**
```yaml
services:
  app:
    image: app/image:${TAG:-latest}
```

---

## Why Use env.* Instead of service.image?

You might wonder: why not just include the tag directly in the image name?

### Direct Approach (Bad):
```json
{
  "image": {
    "type": "string",
    "default": "jellyfin/jellyfin:latest",
    "schema": "service.image"
  }
}
```

**Problems:**
1. User must type the full image string including tag
2. Hard to update just the tag later
3. No separation of concerns

### env.* Approach (Good):
```json
{
  "image": {
    "type": "string",
    "default": "jellyfin/jellyfin",
    "schema": "service.image"
  },
  "tag": {
    "type": "string",
    "default": "latest",
    "schema": "env.TAG"
  }
}
```

**Backend automatically combines them:**
```python
# From compose_generator.py
if 'image' in service_config:
    image = service_config['image']
    if ':' not in image and '$' not in image:
        service_config['image'] = f"{image}:${{TAG:-latest}}"
```

**Result in Compose:**
```yaml
image: jellyfin/jellyfin:${TAG:-latest}
```

**Benefits:**
1. Separate concerns (image vs version)
2. Easy to update version without touching image name
3. Default fallback if TAG not set: `${TAG:-latest}`
4. Can change TAG without regenerating compose file

---

## Advanced: Custom Environment Variables

You can also create custom environment variables for app-specific config:

### Example: Custom API Endpoint

```json
{
  "api_endpoint": {
    "type": "string",
    "ui_component": "text",
    "label": "API Endpoint URL",
    "default": "https://api.example.com",
    "description": "Custom API endpoint",
    "schema": "env.API_ENDPOINT"
  }
}
```

**Generated .env:**
```env
HOST_PATH=/opt/mastarr/stacks/app
TAG=latest
API_ENDPOINT=https://api.example.com
```

**Usage in Compose:**
```yaml
services:
  app:
    image: myapp:${TAG}
    environment:
      API_URL: ${API_ENDPOINT}
```

---

## env.* vs service.environment.*

It's important to understand the difference:

### `env.*` - Goes to .env file

```json
{
  "tag": {
    "type": "string",
    "schema": "env.TAG"
  }
}
```

**Result:**
- `.env` file: `TAG=latest`
- Compose file: `image: app:${TAG}`
- Variable substitution happens during `docker compose up`

**Use when:**
- Value is used in compose file itself (image tags, volume paths)
- Want to easily change value without regenerating compose
- Need variable substitution

### `service.environment.*` - Goes to container environment

```json
{
  "puid": {
    "type": "integer",
    "schema": "service.environment.PUID"
  }
}
```

**Result:**
- Compose file:
  ```yaml
  environment:
    PUID: 1000
  ```
- Variable is set inside the container
- Value is fixed at generation time

**Use when:**
- Value is needed by the application running in the container
- Value should be part of the compose definition
- Don't need to change it without regenerating

---

## File Structure

When an app is installed, its stack directory contains:

```
/opt/mastarr/stacks/app_name/
├── .env                    # Generated environment file
├── docker-compose.yml      # Generated compose file
└── data/                   # App-specific data
```

The `.env` file is **automatically loaded** by Docker Compose when running:
```bash
cd /opt/mastarr/stacks/app_name
docker compose up -d
```

No need to specify it explicitly - Docker Compose looks for `.env` in the same directory.

---

## Variable Expansion in Compose

Docker Compose supports several variable expansion syntaxes:

### Simple Substitution
```yaml
image: ${TAG}
```
If `TAG` is not set, this is an error.

### With Default Value
```yaml
image: ${TAG:-latest}
```
If `TAG` is not set or empty, use `latest`.

### With Default Only if Unset
```yaml
image: ${TAG-latest}
```
If `TAG` is unset, use `latest`. If `TAG` is empty string, use empty string.

**Mastarr uses:** `${TAG:-latest}` (with hyphen-colon) for safety.

---

## Debugging

### Check Generated .env File

```bash
cat /opt/mastarr/stacks/jellyfin_1234567890/.env
```

### Check What Docker Compose Sees

```bash
cd /opt/mastarr/stacks/jellyfin_1234567890
docker compose config
```

This shows the final compose file with all variables substituted.

### Common Issues

**Variable not substituted:**
- Check `.env` file exists in stack directory
- Verify variable name matches exactly (case-sensitive)
- Ensure no typos in compose file

**Wrong value used:**
- Check `.env` file content
- Verify no other `.env` file in parent directories
- Docker Compose reads nearest `.env` file

---

## Summary

The `env.*` schema routing:

1. **Purpose:** Create environment variables for Docker Compose variable substitution
2. **Location:** Values written to `.env` file in stack directory
3. **Usage:** Reference in compose file as `${VARIABLE_NAME}`
4. **Auto-included:** `HOST_PATH` always added automatically
5. **Common use:** Image tags, paths, and other compose-level configuration
6. **Different from:** `service.environment.*` which sets container environment variables

This system allows for flexible configuration that can be easily changed without regenerating the entire Docker Compose file.
